name: plugins-release-tag

on:
  push:
    tags:
      # This workflow triggers on tags prefixed with a plugin name, e.g.,
      # collaborator-plugin/1.0.3
      # teamrepo-plugin/2.8.1
      - '*-plugin/*'  # wildcard for any plugin name

jobs:
  test-and-lint-code:
    runs-on: ubuntu-latest
    
    # Set the working directory to the plugins root
    defaults:
      run:
        working-directory: ./plugins

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache-dependency-path: "plugins/go.work.sum"

      - name: Run Go Tests
        run: go test -v -cover $(go work edit -json | jq -r '.Use[].DiskPath' | sed 's|$|/...|' | tr '\n' ' ')
  
  # Parse the Git tag to get the plugin name and version.
  parse-tag:
    runs-on: ubuntu-latest
    outputs:
      plugin: ${{ steps.parse.outputs.plugin }}
      version: ${{ steps.parse.outputs.version }}
    steps:
      - name: Parse Git Tag # Tag format: plugin-name/X.Y.Z (e.g., collaborator-plugin/1.0.3)
        id: parse
        run: |
          TAG="${{ github.ref_name }}"
          PLUGIN="${TAG%%/*}"   # before first slash
          VERSION="${TAG##*/}"  # after last slash
          echo "plugin=${PLUGIN}" >> $GITHUB_OUTPUT
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          if [[ "$PLUGIN" == *-plugin ]]; then
            echo "Plugin name: $PLUGIN"
          else
            echo "Invalid plugin name format: $PLUGIN"
            echo "Expected format: <name>-plugin (e.g., collaborator-plugin)"
            exit 1
          fi
          if ! [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Invalid version format: $VERSION"
            echo "Expected format: X.Y.Z (e.g., 1.0.3)"
            exit 1
          fi

  # Build and publish multi-arch container images for the specific plugin.
  build-and-publish-image:
    needs: parse-tag
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: linux/amd64
            platform_name: linux-amd64
          - platform: linux/arm64
            platform_name: linux-arm64
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Build and push by digest
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ./plugins
          file: ./plugins/Dockerfile
          platforms: ${{ matrix.platform }}
          push: true
          labels: "org.opencontainers.image.version=${{ needs.parse-tag.outputs.version }}"
          outputs: type=image,name=ghcr.io/${{ github.repository_owner }}/github-provider-kog/${{ needs.parse-tag.outputs.plugin }},push-by-digest=true,name-canonical=true,push=true
          build-args: |
            PLUGIN_NAME=${{ needs.parse-tag.outputs.plugin }}
      
      - name: Export digest
        run: |
          mkdir -p "/tmp/digests/${{ matrix.platform_name }}"
          digest="${{ steps.build.outputs.digest }}"
          echo "DEBUG: digest='${digest}'" >&2
          if [ -z "$digest" ]; then
            echo "ERROR: build produced no digest (steps.build.outputs.digest empty). Aborting." >&2
            exit 1
          fi
          echo "${digest}" > "/tmp/digests/${{ matrix.platform_name }}/digest"
      
      - name: Upload digest
        uses: actions/upload-artifact@v4
        with:
          name: digests-${{ needs.parse-tag.outputs.plugin }}-${{ matrix.platform_name }}
          path: /tmp/digests/${{ matrix.platform_name }}/
          if-no-files-found: error
          retention-days: 1

  # Merge the multi-arch manifests.
  merge-manifest:
    needs: [parse-tag, build-and-publish-image]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Download digests
        uses: actions/download-artifact@v4
        with:
          pattern: digests-${{ needs.parse-tag.outputs.plugin }}-*
          path: /tmp/digests
          merge-multiple: true
      
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository_owner }}/github-provider-kog/${{ needs.parse-tag.outputs.plugin }}
          tags: type=raw,value=${{ needs.parse-tag.outputs.version }}
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Create and push manifest list
        run: |
          set -euo pipefail
          REG="ghcr.io/${{ github.repository_owner }}/github-provider-kog/${{ needs.parse-tag.outputs.plugin }}"

          # Build full image@sha references from the downloaded digest files.
          IMAGES=""
          for f in /tmp/digests/*/digest; do
            d="$(cat "$f")"  # e.g. sha256:abcd...
            if [ -z "$d" ]; then
              echo "ERROR: empty digest in $f" >&2
              exit 1
            fi
            if [[ "${d:-}" != sha256:* ]]; then
              d="sha256:${d}"
            fi
            IMAGES="$IMAGES ${REG}@${d}"
          done

          # Expand tags from metadata JSON into multiple -t args
          TAG_OPTS=$(jq -cr '.tags | map("-t " + .) | join(" ")' <<< '${{ steps.meta.outputs.json }}')
          if [ -z "${IMAGES}" ]; then
            echo "ERROR: no images to merge (no digest files found)." >&2
            exit 1
          fi

          echo "docker buildx imagetools create ${TAG_OPTS} ${IMAGES}"
          eval "docker buildx imagetools create ${TAG_OPTS} ${IMAGES}"

  # Release the specific Helm chart for the plugin.
  release-plugin-chart:
    needs: [parse-tag, merge-manifest]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Authenticate with GitHub App
        id: authenticate
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.PRIVATE_KEY }}
      
      - name: Set up Helm
        uses: azure/setup-helm@v4.1.0
      
      - name: Ensure yq is installed
        run: |
          if ! command -v yq >/dev/null; then
            echo "Installing yq..."
            # Mike Farah yq (Linux amd64); adjust for arm if needed
            YQ_BIN=/usr/local/bin/yq
            sudo curl -sSL "https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64" -o "${YQ_BIN}"
            sudo chmod +x "${YQ_BIN}"
          fi
          echo "yq version: $(yq --version)"
      
      - name: Update Chart Versions
        run: |
          CHART_DIR="./${{ needs.parse-tag.outputs.plugin }}-chart"
          NEW_VERSION="${{ needs.parse-tag.outputs.version }}"
          echo "Updating ${CHART_DIR} to version ${NEW_VERSION}"
          yq e ".version = \"${NEW_VERSION}\" | .appVersion = \"${NEW_VERSION}\"" -i "${CHART_DIR}/Chart.yaml"
          yq e ".image.tag = \"${NEW_VERSION}\"" -i "${CHART_DIR}/values.yaml"

      - name: Helm lint
        run: |
          CHART_DIR="./${{ needs.parse-tag.outputs.plugin }}-chart"
          helm lint "${CHART_DIR}"
      
      - name: Publish Helm chart to gh-pages
        uses: stefanprodan/helm-gh-pages@v1.7.0
        with:
          token: ${{ steps.authenticate.outputs.token }}
          charts_dir: ./${{ needs.parse-tag.outputs.plugin }}-chart
          charts_url: https://marketplace.krateo.io
          owner: krateoplatformops-blueprints
          repository: marketplace
          branch: gh-pages
